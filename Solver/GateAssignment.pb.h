// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GateAssignment.proto

#ifndef PROTOBUF_INCLUDED_GateAssignment_2eproto
#define PROTOBUF_INCLUDED_GateAssignment_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_GateAssignment_2eproto 

namespace protobuf_GateAssignment_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_GateAssignment_2eproto
namespace pb {
class Airport;
class AirportDefaultTypeInternal;
extern AirportDefaultTypeInternal _Airport_default_instance_;
class Flight;
class FlightDefaultTypeInternal;
extern FlightDefaultTypeInternal _Flight_default_instance_;
class Gate;
class GateDefaultTypeInternal;
extern GateDefaultTypeInternal _Gate_default_instance_;
class GateAssignment;
class GateAssignmentDefaultTypeInternal;
extern GateAssignmentDefaultTypeInternal _GateAssignment_default_instance_;
class GateAssignment_Input;
class GateAssignment_InputDefaultTypeInternal;
extern GateAssignment_InputDefaultTypeInternal _GateAssignment_Input_default_instance_;
class GateAssignment_Output;
class GateAssignment_OutputDefaultTypeInternal;
extern GateAssignment_OutputDefaultTypeInternal _GateAssignment_Output_default_instance_;
class Interval;
class IntervalDefaultTypeInternal;
extern IntervalDefaultTypeInternal _Interval_default_instance_;
class Submission;
class SubmissionDefaultTypeInternal;
extern SubmissionDefaultTypeInternal _Submission_default_instance_;
}  // namespace pb
namespace google {
namespace protobuf {
template<> ::pb::Airport* Arena::CreateMaybeMessage<::pb::Airport>(Arena*);
template<> ::pb::Flight* Arena::CreateMaybeMessage<::pb::Flight>(Arena*);
template<> ::pb::Gate* Arena::CreateMaybeMessage<::pb::Gate>(Arena*);
template<> ::pb::GateAssignment* Arena::CreateMaybeMessage<::pb::GateAssignment>(Arena*);
template<> ::pb::GateAssignment_Input* Arena::CreateMaybeMessage<::pb::GateAssignment_Input>(Arena*);
template<> ::pb::GateAssignment_Output* Arena::CreateMaybeMessage<::pb::GateAssignment_Output>(Arena*);
template<> ::pb::Interval* Arena::CreateMaybeMessage<::pb::Interval>(Arena*);
template<> ::pb::Submission* Arena::CreateMaybeMessage<::pb::Submission>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb {

// ===================================================================

class GateAssignment_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GateAssignment.Input) */ {
 public:
  GateAssignment_Input();
  virtual ~GateAssignment_Input();

  GateAssignment_Input(const GateAssignment_Input& from);

  inline GateAssignment_Input& operator=(const GateAssignment_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GateAssignment_Input(GateAssignment_Input&& from) noexcept
    : GateAssignment_Input() {
    *this = ::std::move(from);
  }

  inline GateAssignment_Input& operator=(GateAssignment_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GateAssignment_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GateAssignment_Input* internal_default_instance() {
    return reinterpret_cast<const GateAssignment_Input*>(
               &_GateAssignment_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GateAssignment_Input* other);
  friend void swap(GateAssignment_Input& a, GateAssignment_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GateAssignment_Input* New() const final {
    return CreateMaybeMessage<GateAssignment_Input>(NULL);
  }

  GateAssignment_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GateAssignment_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GateAssignment_Input& from);
  void MergeFrom(const GateAssignment_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GateAssignment_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Flight flights = 2;
  int flights_size() const;
  void clear_flights();
  static const int kFlightsFieldNumber = 2;
  ::pb::Flight* mutable_flights(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Flight >*
      mutable_flights();
  const ::pb::Flight& flights(int index) const;
  ::pb::Flight* add_flights();
  const ::google::protobuf::RepeatedPtrField< ::pb::Flight >&
      flights() const;

  // .pb.Airport airport = 1;
  bool has_airport() const;
  void clear_airport();
  static const int kAirportFieldNumber = 1;
  private:
  const ::pb::Airport& _internal_airport() const;
  public:
  const ::pb::Airport& airport() const;
  ::pb::Airport* release_airport();
  ::pb::Airport* mutable_airport();
  void set_allocated_airport(::pb::Airport* airport);

  // @@protoc_insertion_point(class_scope:pb.GateAssignment.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Flight > flights_;
  ::pb::Airport* airport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GateAssignment_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GateAssignment.Output) */ {
 public:
  GateAssignment_Output();
  virtual ~GateAssignment_Output();

  GateAssignment_Output(const GateAssignment_Output& from);

  inline GateAssignment_Output& operator=(const GateAssignment_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GateAssignment_Output(GateAssignment_Output&& from) noexcept
    : GateAssignment_Output() {
    *this = ::std::move(from);
  }

  inline GateAssignment_Output& operator=(GateAssignment_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GateAssignment_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GateAssignment_Output* internal_default_instance() {
    return reinterpret_cast<const GateAssignment_Output*>(
               &_GateAssignment_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GateAssignment_Output* other);
  friend void swap(GateAssignment_Output& a, GateAssignment_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GateAssignment_Output* New() const final {
    return CreateMaybeMessage<GateAssignment_Output>(NULL);
  }

  GateAssignment_Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GateAssignment_Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GateAssignment_Output& from);
  void MergeFrom(const GateAssignment_Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GateAssignment_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 assignments = 1;
  int assignments_size() const;
  void clear_assignments();
  static const int kAssignmentsFieldNumber = 1;
  ::google::protobuf::int32 assignments(int index) const;
  void set_assignments(int index, ::google::protobuf::int32 value);
  void add_assignments(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      assignments() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_assignments();

  // @@protoc_insertion_point(class_scope:pb.GateAssignment.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > assignments_;
  mutable int _assignments_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GateAssignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.GateAssignment) */ {
 public:
  GateAssignment();
  virtual ~GateAssignment();

  GateAssignment(const GateAssignment& from);

  inline GateAssignment& operator=(const GateAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GateAssignment(GateAssignment&& from) noexcept
    : GateAssignment() {
    *this = ::std::move(from);
  }

  inline GateAssignment& operator=(GateAssignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GateAssignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GateAssignment* internal_default_instance() {
    return reinterpret_cast<const GateAssignment*>(
               &_GateAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GateAssignment* other);
  friend void swap(GateAssignment& a, GateAssignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GateAssignment* New() const final {
    return CreateMaybeMessage<GateAssignment>(NULL);
  }

  GateAssignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GateAssignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GateAssignment& from);
  void MergeFrom(const GateAssignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GateAssignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GateAssignment_Input Input;
  typedef GateAssignment_Output Output;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.GateAssignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Airport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Airport) */ {
 public:
  Airport();
  virtual ~Airport();

  Airport(const Airport& from);

  inline Airport& operator=(const Airport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Airport(Airport&& from) noexcept
    : Airport() {
    *this = ::std::move(from);
  }

  inline Airport& operator=(Airport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Airport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Airport* internal_default_instance() {
    return reinterpret_cast<const Airport*>(
               &_Airport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Airport* other);
  friend void swap(Airport& a, Airport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Airport* New() const final {
    return CreateMaybeMessage<Airport>(NULL);
  }

  Airport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Airport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Airport& from);
  void MergeFrom(const Airport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Airport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Gate gates = 1;
  int gates_size() const;
  void clear_gates();
  static const int kGatesFieldNumber = 1;
  ::pb::Gate* mutable_gates(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Gate >*
      mutable_gates();
  const ::pb::Gate& gates(int index) const;
  ::pb::Gate* add_gates();
  const ::google::protobuf::RepeatedPtrField< ::pb::Gate >&
      gates() const;

  // int32 bridgeNum = 2;
  void clear_bridgenum();
  static const int kBridgeNumFieldNumber = 2;
  ::google::protobuf::int32 bridgenum() const;
  void set_bridgenum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Airport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Gate > gates_;
  ::google::protobuf::int32 bridgenum_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Gate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Gate) */ {
 public:
  Gate();
  virtual ~Gate();

  Gate(const Gate& from);

  inline Gate& operator=(const Gate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Gate(Gate&& from) noexcept
    : Gate() {
    *this = ::std::move(from);
  }

  inline Gate& operator=(Gate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Gate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Gate* internal_default_instance() {
    return reinterpret_cast<const Gate*>(
               &_Gate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Gate* other);
  friend void swap(Gate& a, Gate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Gate* New() const final {
    return CreateMaybeMessage<Gate>(NULL);
  }

  Gate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Gate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Gate& from);
  void MergeFrom(const Gate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 minGap = 2;
  void clear_mingap();
  static const int kMinGapFieldNumber = 2;
  ::google::protobuf::int32 mingap() const;
  void set_mingap(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Gate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 mingap_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Flight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Flight) */ {
 public:
  Flight();
  virtual ~Flight();

  Flight(const Flight& from);

  inline Flight& operator=(const Flight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Flight(Flight&& from) noexcept
    : Flight() {
    *this = ::std::move(from);
  }

  inline Flight& operator=(Flight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Flight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Flight* internal_default_instance() {
    return reinterpret_cast<const Flight*>(
               &_Flight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Flight* other);
  friend void swap(Flight& a, Flight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Flight* New() const final {
    return CreateMaybeMessage<Flight>(NULL);
  }

  Flight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Flight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Flight& from);
  void MergeFrom(const Flight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 incompatibleGates = 3;
  int incompatiblegates_size() const;
  void clear_incompatiblegates();
  static const int kIncompatibleGatesFieldNumber = 3;
  ::google::protobuf::int32 incompatiblegates(int index) const;
  void set_incompatiblegates(int index, ::google::protobuf::int32 value);
  void add_incompatiblegates(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      incompatiblegates() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_incompatiblegates();

  // .pb.Interval turnaround = 2;
  bool has_turnaround() const;
  void clear_turnaround();
  static const int kTurnaroundFieldNumber = 2;
  private:
  const ::pb::Interval& _internal_turnaround() const;
  public:
  const ::pb::Interval& turnaround() const;
  ::pb::Interval* release_turnaround();
  ::pb::Interval* mutable_turnaround();
  void set_allocated_turnaround(::pb::Interval* turnaround);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Flight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > incompatiblegates_;
  mutable int _incompatiblegates_cached_byte_size_;
  ::pb::Interval* turnaround_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Interval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Interval) */ {
 public:
  Interval();
  virtual ~Interval();

  Interval(const Interval& from);

  inline Interval& operator=(const Interval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Interval(Interval&& from) noexcept
    : Interval() {
    *this = ::std::move(from);
  }

  inline Interval& operator=(Interval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Interval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Interval* internal_default_instance() {
    return reinterpret_cast<const Interval*>(
               &_Interval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Interval* other);
  friend void swap(Interval& a, Interval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Interval* New() const final {
    return CreateMaybeMessage<Interval>(NULL);
  }

  Interval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Interval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Interval& from);
  void MergeFrom(const Interval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 begin = 1;
  void clear_begin();
  static const int kBeginFieldNumber = 1;
  ::google::protobuf::int32 begin() const;
  void set_begin(::google::protobuf::int32 value);

  // int32 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Interval)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Submission : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Submission) */ {
 public:
  Submission();
  virtual ~Submission();

  Submission(const Submission& from);

  inline Submission& operator=(const Submission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Submission(Submission&& from) noexcept
    : Submission() {
    *this = ::std::move(from);
  }

  inline Submission& operator=(Submission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Submission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Submission* internal_default_instance() {
    return reinterpret_cast<const Submission*>(
               &_Submission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Submission* other);
  friend void swap(Submission& a, Submission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Submission* New() const final {
    return CreateMaybeMessage<Submission>(NULL);
  }

  Submission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Submission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Submission& from);
  void MergeFrom(const Submission& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Submission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string author = 1;
  void clear_author();
  static const int kAuthorFieldNumber = 1;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // string algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  const ::std::string& algorithm() const;
  void set_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_algorithm(::std::string&& value);
  #endif
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  ::std::string* mutable_algorithm();
  ::std::string* release_algorithm();
  void set_allocated_algorithm(::std::string* algorithm);

  // string thread = 3;
  void clear_thread();
  static const int kThreadFieldNumber = 3;
  const ::std::string& thread() const;
  void set_thread(const ::std::string& value);
  #if LANG_CXX11
  void set_thread(::std::string&& value);
  #endif
  void set_thread(const char* value);
  void set_thread(const char* value, size_t size);
  ::std::string* mutable_thread();
  ::std::string* release_thread();
  void set_allocated_thread(::std::string* thread);

  // string cpu = 4;
  void clear_cpu();
  static const int kCpuFieldNumber = 4;
  const ::std::string& cpu() const;
  void set_cpu(const ::std::string& value);
  #if LANG_CXX11
  void set_cpu(::std::string&& value);
  #endif
  void set_cpu(const char* value);
  void set_cpu(const char* value, size_t size);
  ::std::string* mutable_cpu();
  ::std::string* release_cpu();
  void set_allocated_cpu(::std::string* cpu);

  // string ram = 5;
  void clear_ram();
  static const int kRamFieldNumber = 5;
  const ::std::string& ram() const;
  void set_ram(const ::std::string& value);
  #if LANG_CXX11
  void set_ram(::std::string&& value);
  #endif
  void set_ram(const char* value);
  void set_ram(const char* value, size_t size);
  ::std::string* mutable_ram();
  ::std::string* release_ram();
  void set_allocated_ram(::std::string* ram);

  // string language = 6;
  void clear_language();
  static const int kLanguageFieldNumber = 6;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // string compiler = 7;
  void clear_compiler();
  static const int kCompilerFieldNumber = 7;
  const ::std::string& compiler() const;
  void set_compiler(const ::std::string& value);
  #if LANG_CXX11
  void set_compiler(::std::string&& value);
  #endif
  void set_compiler(const char* value);
  void set_compiler(const char* value, size_t size);
  ::std::string* mutable_compiler();
  ::std::string* release_compiler();
  void set_allocated_compiler(::std::string* compiler);

  // string os = 8;
  void clear_os();
  static const int kOsFieldNumber = 8;
  const ::std::string& os() const;
  void set_os(const ::std::string& value);
  #if LANG_CXX11
  void set_os(::std::string&& value);
  #endif
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  ::std::string* mutable_os();
  ::std::string* release_os();
  void set_allocated_os(::std::string* os);

  // string problem = 21;
  void clear_problem();
  static const int kProblemFieldNumber = 21;
  const ::std::string& problem() const;
  void set_problem(const ::std::string& value);
  #if LANG_CXX11
  void set_problem(::std::string&& value);
  #endif
  void set_problem(const char* value);
  void set_problem(const char* value, size_t size);
  ::std::string* mutable_problem();
  ::std::string* release_problem();
  void set_allocated_problem(::std::string* problem);

  // string instance = 22;
  void clear_instance();
  static const int kInstanceFieldNumber = 22;
  const ::std::string& instance() const;
  void set_instance(const ::std::string& value);
  #if LANG_CXX11
  void set_instance(::std::string&& value);
  #endif
  void set_instance(const char* value);
  void set_instance(const char* value, size_t size);
  ::std::string* mutable_instance();
  ::std::string* release_instance();
  void set_allocated_instance(::std::string* instance);

  // string duration = 23;
  void clear_duration();
  static const int kDurationFieldNumber = 23;
  const ::std::string& duration() const;
  void set_duration(const ::std::string& value);
  #if LANG_CXX11
  void set_duration(::std::string&& value);
  #endif
  void set_duration(const char* value);
  void set_duration(const char* value, size_t size);
  ::std::string* mutable_duration();
  ::std::string* release_duration();
  void set_allocated_duration(::std::string* duration);

  // string email = 32;
  void clear_email();
  static const int kEmailFieldNumber = 32;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string date = 33;
  void clear_date();
  static const int kDateFieldNumber = 33;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // double obj = 31;
  void clear_obj();
  static const int kObjFieldNumber = 31;
  double obj() const;
  void set_obj(double value);

  // @@protoc_insertion_point(class_scope:pb.Submission)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr algorithm_;
  ::google::protobuf::internal::ArenaStringPtr thread_;
  ::google::protobuf::internal::ArenaStringPtr cpu_;
  ::google::protobuf::internal::ArenaStringPtr ram_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr compiler_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  ::google::protobuf::internal::ArenaStringPtr problem_;
  ::google::protobuf::internal::ArenaStringPtr instance_;
  ::google::protobuf::internal::ArenaStringPtr duration_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  double obj_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_GateAssignment_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GateAssignment_Input

// .pb.Airport airport = 1;
inline bool GateAssignment_Input::has_airport() const {
  return this != internal_default_instance() && airport_ != NULL;
}
inline void GateAssignment_Input::clear_airport() {
  if (GetArenaNoVirtual() == NULL && airport_ != NULL) {
    delete airport_;
  }
  airport_ = NULL;
}
inline const ::pb::Airport& GateAssignment_Input::_internal_airport() const {
  return *airport_;
}
inline const ::pb::Airport& GateAssignment_Input::airport() const {
  const ::pb::Airport* p = airport_;
  // @@protoc_insertion_point(field_get:pb.GateAssignment.Input.airport)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::Airport*>(
      &::pb::_Airport_default_instance_);
}
inline ::pb::Airport* GateAssignment_Input::release_airport() {
  // @@protoc_insertion_point(field_release:pb.GateAssignment.Input.airport)
  
  ::pb::Airport* temp = airport_;
  airport_ = NULL;
  return temp;
}
inline ::pb::Airport* GateAssignment_Input::mutable_airport() {
  
  if (airport_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::Airport>(GetArenaNoVirtual());
    airport_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.GateAssignment.Input.airport)
  return airport_;
}
inline void GateAssignment_Input::set_allocated_airport(::pb::Airport* airport) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete airport_;
  }
  if (airport) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      airport = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, airport, submessage_arena);
    }
    
  } else {
    
  }
  airport_ = airport;
  // @@protoc_insertion_point(field_set_allocated:pb.GateAssignment.Input.airport)
}

// repeated .pb.Flight flights = 2;
inline int GateAssignment_Input::flights_size() const {
  return flights_.size();
}
inline void GateAssignment_Input::clear_flights() {
  flights_.Clear();
}
inline ::pb::Flight* GateAssignment_Input::mutable_flights(int index) {
  // @@protoc_insertion_point(field_mutable:pb.GateAssignment.Input.flights)
  return flights_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Flight >*
GateAssignment_Input::mutable_flights() {
  // @@protoc_insertion_point(field_mutable_list:pb.GateAssignment.Input.flights)
  return &flights_;
}
inline const ::pb::Flight& GateAssignment_Input::flights(int index) const {
  // @@protoc_insertion_point(field_get:pb.GateAssignment.Input.flights)
  return flights_.Get(index);
}
inline ::pb::Flight* GateAssignment_Input::add_flights() {
  // @@protoc_insertion_point(field_add:pb.GateAssignment.Input.flights)
  return flights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Flight >&
GateAssignment_Input::flights() const {
  // @@protoc_insertion_point(field_list:pb.GateAssignment.Input.flights)
  return flights_;
}

// -------------------------------------------------------------------

// GateAssignment_Output

// repeated int32 assignments = 1;
inline int GateAssignment_Output::assignments_size() const {
  return assignments_.size();
}
inline void GateAssignment_Output::clear_assignments() {
  assignments_.Clear();
}
inline ::google::protobuf::int32 GateAssignment_Output::assignments(int index) const {
  // @@protoc_insertion_point(field_get:pb.GateAssignment.Output.assignments)
  return assignments_.Get(index);
}
inline void GateAssignment_Output::set_assignments(int index, ::google::protobuf::int32 value) {
  assignments_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.GateAssignment.Output.assignments)
}
inline void GateAssignment_Output::add_assignments(::google::protobuf::int32 value) {
  assignments_.Add(value);
  // @@protoc_insertion_point(field_add:pb.GateAssignment.Output.assignments)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GateAssignment_Output::assignments() const {
  // @@protoc_insertion_point(field_list:pb.GateAssignment.Output.assignments)
  return assignments_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GateAssignment_Output::mutable_assignments() {
  // @@protoc_insertion_point(field_mutable_list:pb.GateAssignment.Output.assignments)
  return &assignments_;
}

// -------------------------------------------------------------------

// GateAssignment

// -------------------------------------------------------------------

// Airport

// repeated .pb.Gate gates = 1;
inline int Airport::gates_size() const {
  return gates_.size();
}
inline void Airport::clear_gates() {
  gates_.Clear();
}
inline ::pb::Gate* Airport::mutable_gates(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Airport.gates)
  return gates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Gate >*
Airport::mutable_gates() {
  // @@protoc_insertion_point(field_mutable_list:pb.Airport.gates)
  return &gates_;
}
inline const ::pb::Gate& Airport::gates(int index) const {
  // @@protoc_insertion_point(field_get:pb.Airport.gates)
  return gates_.Get(index);
}
inline ::pb::Gate* Airport::add_gates() {
  // @@protoc_insertion_point(field_add:pb.Airport.gates)
  return gates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Gate >&
Airport::gates() const {
  // @@protoc_insertion_point(field_list:pb.Airport.gates)
  return gates_;
}

// int32 bridgeNum = 2;
inline void Airport::clear_bridgenum() {
  bridgenum_ = 0;
}
inline ::google::protobuf::int32 Airport::bridgenum() const {
  // @@protoc_insertion_point(field_get:pb.Airport.bridgeNum)
  return bridgenum_;
}
inline void Airport::set_bridgenum(::google::protobuf::int32 value) {
  
  bridgenum_ = value;
  // @@protoc_insertion_point(field_set:pb.Airport.bridgeNum)
}

// -------------------------------------------------------------------

// Gate

// int32 id = 1;
inline void Gate::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Gate::id() const {
  // @@protoc_insertion_point(field_get:pb.Gate.id)
  return id_;
}
inline void Gate::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Gate.id)
}

// int32 minGap = 2;
inline void Gate::clear_mingap() {
  mingap_ = 0;
}
inline ::google::protobuf::int32 Gate::mingap() const {
  // @@protoc_insertion_point(field_get:pb.Gate.minGap)
  return mingap_;
}
inline void Gate::set_mingap(::google::protobuf::int32 value) {
  
  mingap_ = value;
  // @@protoc_insertion_point(field_set:pb.Gate.minGap)
}

// -------------------------------------------------------------------

// Flight

// int32 id = 1;
inline void Flight::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Flight::id() const {
  // @@protoc_insertion_point(field_get:pb.Flight.id)
  return id_;
}
inline void Flight::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Flight.id)
}

// .pb.Interval turnaround = 2;
inline bool Flight::has_turnaround() const {
  return this != internal_default_instance() && turnaround_ != NULL;
}
inline void Flight::clear_turnaround() {
  if (GetArenaNoVirtual() == NULL && turnaround_ != NULL) {
    delete turnaround_;
  }
  turnaround_ = NULL;
}
inline const ::pb::Interval& Flight::_internal_turnaround() const {
  return *turnaround_;
}
inline const ::pb::Interval& Flight::turnaround() const {
  const ::pb::Interval* p = turnaround_;
  // @@protoc_insertion_point(field_get:pb.Flight.turnaround)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::Interval*>(
      &::pb::_Interval_default_instance_);
}
inline ::pb::Interval* Flight::release_turnaround() {
  // @@protoc_insertion_point(field_release:pb.Flight.turnaround)
  
  ::pb::Interval* temp = turnaround_;
  turnaround_ = NULL;
  return temp;
}
inline ::pb::Interval* Flight::mutable_turnaround() {
  
  if (turnaround_ == NULL) {
    auto* p = CreateMaybeMessage<::pb::Interval>(GetArenaNoVirtual());
    turnaround_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.Flight.turnaround)
  return turnaround_;
}
inline void Flight::set_allocated_turnaround(::pb::Interval* turnaround) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete turnaround_;
  }
  if (turnaround) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      turnaround = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, turnaround, submessage_arena);
    }
    
  } else {
    
  }
  turnaround_ = turnaround;
  // @@protoc_insertion_point(field_set_allocated:pb.Flight.turnaround)
}

// repeated int32 incompatibleGates = 3;
inline int Flight::incompatiblegates_size() const {
  return incompatiblegates_.size();
}
inline void Flight::clear_incompatiblegates() {
  incompatiblegates_.Clear();
}
inline ::google::protobuf::int32 Flight::incompatiblegates(int index) const {
  // @@protoc_insertion_point(field_get:pb.Flight.incompatibleGates)
  return incompatiblegates_.Get(index);
}
inline void Flight::set_incompatiblegates(int index, ::google::protobuf::int32 value) {
  incompatiblegates_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.Flight.incompatibleGates)
}
inline void Flight::add_incompatiblegates(::google::protobuf::int32 value) {
  incompatiblegates_.Add(value);
  // @@protoc_insertion_point(field_add:pb.Flight.incompatibleGates)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Flight::incompatiblegates() const {
  // @@protoc_insertion_point(field_list:pb.Flight.incompatibleGates)
  return incompatiblegates_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Flight::mutable_incompatiblegates() {
  // @@protoc_insertion_point(field_mutable_list:pb.Flight.incompatibleGates)
  return &incompatiblegates_;
}

// -------------------------------------------------------------------

// Interval

// int32 begin = 1;
inline void Interval::clear_begin() {
  begin_ = 0;
}
inline ::google::protobuf::int32 Interval::begin() const {
  // @@protoc_insertion_point(field_get:pb.Interval.begin)
  return begin_;
}
inline void Interval::set_begin(::google::protobuf::int32 value) {
  
  begin_ = value;
  // @@protoc_insertion_point(field_set:pb.Interval.begin)
}

// int32 end = 2;
inline void Interval::clear_end() {
  end_ = 0;
}
inline ::google::protobuf::int32 Interval::end() const {
  // @@protoc_insertion_point(field_get:pb.Interval.end)
  return end_;
}
inline void Interval::set_end(::google::protobuf::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:pb.Interval.end)
}

// -------------------------------------------------------------------

// Submission

// string author = 1;
inline void Submission::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::author() const {
  // @@protoc_insertion_point(field_get:pb.Submission.author)
  return author_.GetNoArena();
}
inline void Submission::set_author(const ::std::string& value) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.author)
}
#if LANG_CXX11
inline void Submission::set_author(::std::string&& value) {
  
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.author)
}
#endif
inline void Submission::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.author)
}
inline void Submission::set_author(const char* value, size_t size) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.author)
}
inline ::std::string* Submission::mutable_author() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_author() {
  // @@protoc_insertion_point(field_release:pb.Submission.author)
  
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    
  } else {
    
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.author)
}

// string algorithm = 2;
inline void Submission::clear_algorithm() {
  algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::algorithm() const {
  // @@protoc_insertion_point(field_get:pb.Submission.algorithm)
  return algorithm_.GetNoArena();
}
inline void Submission::set_algorithm(const ::std::string& value) {
  
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.algorithm)
}
#if LANG_CXX11
inline void Submission::set_algorithm(::std::string&& value) {
  
  algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.algorithm)
}
#endif
inline void Submission::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.algorithm)
}
inline void Submission::set_algorithm(const char* value, size_t size) {
  
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.algorithm)
}
inline ::std::string* Submission::mutable_algorithm() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.algorithm)
  return algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_algorithm() {
  // @@protoc_insertion_point(field_release:pb.Submission.algorithm)
  
  return algorithm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_algorithm(::std::string* algorithm) {
  if (algorithm != NULL) {
    
  } else {
    
  }
  algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), algorithm);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.algorithm)
}

// string thread = 3;
inline void Submission::clear_thread() {
  thread_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::thread() const {
  // @@protoc_insertion_point(field_get:pb.Submission.thread)
  return thread_.GetNoArena();
}
inline void Submission::set_thread(const ::std::string& value) {
  
  thread_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.thread)
}
#if LANG_CXX11
inline void Submission::set_thread(::std::string&& value) {
  
  thread_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.thread)
}
#endif
inline void Submission::set_thread(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thread_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.thread)
}
inline void Submission::set_thread(const char* value, size_t size) {
  
  thread_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.thread)
}
inline ::std::string* Submission::mutable_thread() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.thread)
  return thread_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_thread() {
  // @@protoc_insertion_point(field_release:pb.Submission.thread)
  
  return thread_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_thread(::std::string* thread) {
  if (thread != NULL) {
    
  } else {
    
  }
  thread_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thread);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.thread)
}

// string cpu = 4;
inline void Submission::clear_cpu() {
  cpu_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::cpu() const {
  // @@protoc_insertion_point(field_get:pb.Submission.cpu)
  return cpu_.GetNoArena();
}
inline void Submission::set_cpu(const ::std::string& value) {
  
  cpu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.cpu)
}
#if LANG_CXX11
inline void Submission::set_cpu(::std::string&& value) {
  
  cpu_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.cpu)
}
#endif
inline void Submission::set_cpu(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cpu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.cpu)
}
inline void Submission::set_cpu(const char* value, size_t size) {
  
  cpu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.cpu)
}
inline ::std::string* Submission::mutable_cpu() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.cpu)
  return cpu_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_cpu() {
  // @@protoc_insertion_point(field_release:pb.Submission.cpu)
  
  return cpu_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_cpu(::std::string* cpu) {
  if (cpu != NULL) {
    
  } else {
    
  }
  cpu_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cpu);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.cpu)
}

// string ram = 5;
inline void Submission::clear_ram() {
  ram_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::ram() const {
  // @@protoc_insertion_point(field_get:pb.Submission.ram)
  return ram_.GetNoArena();
}
inline void Submission::set_ram(const ::std::string& value) {
  
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.ram)
}
#if LANG_CXX11
inline void Submission::set_ram(::std::string&& value) {
  
  ram_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.ram)
}
#endif
inline void Submission::set_ram(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.ram)
}
inline void Submission::set_ram(const char* value, size_t size) {
  
  ram_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.ram)
}
inline ::std::string* Submission::mutable_ram() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.ram)
  return ram_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_ram() {
  // @@protoc_insertion_point(field_release:pb.Submission.ram)
  
  return ram_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_ram(::std::string* ram) {
  if (ram != NULL) {
    
  } else {
    
  }
  ram_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ram);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.ram)
}

// string language = 6;
inline void Submission::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::language() const {
  // @@protoc_insertion_point(field_get:pb.Submission.language)
  return language_.GetNoArena();
}
inline void Submission::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.language)
}
#if LANG_CXX11
inline void Submission::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.language)
}
#endif
inline void Submission::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.language)
}
inline void Submission::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.language)
}
inline ::std::string* Submission::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_language() {
  // @@protoc_insertion_point(field_release:pb.Submission.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.language)
}

// string compiler = 7;
inline void Submission::clear_compiler() {
  compiler_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::compiler() const {
  // @@protoc_insertion_point(field_get:pb.Submission.compiler)
  return compiler_.GetNoArena();
}
inline void Submission::set_compiler(const ::std::string& value) {
  
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.compiler)
}
#if LANG_CXX11
inline void Submission::set_compiler(::std::string&& value) {
  
  compiler_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.compiler)
}
#endif
inline void Submission::set_compiler(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.compiler)
}
inline void Submission::set_compiler(const char* value, size_t size) {
  
  compiler_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.compiler)
}
inline ::std::string* Submission::mutable_compiler() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.compiler)
  return compiler_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_compiler() {
  // @@protoc_insertion_point(field_release:pb.Submission.compiler)
  
  return compiler_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_compiler(::std::string* compiler) {
  if (compiler != NULL) {
    
  } else {
    
  }
  compiler_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), compiler);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.compiler)
}

// string os = 8;
inline void Submission::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::os() const {
  // @@protoc_insertion_point(field_get:pb.Submission.os)
  return os_.GetNoArena();
}
inline void Submission::set_os(const ::std::string& value) {
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.os)
}
#if LANG_CXX11
inline void Submission::set_os(::std::string&& value) {
  
  os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.os)
}
#endif
inline void Submission::set_os(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.os)
}
inline void Submission::set_os(const char* value, size_t size) {
  
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.os)
}
inline ::std::string* Submission::mutable_os() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_os() {
  // @@protoc_insertion_point(field_release:pb.Submission.os)
  
  return os_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_os(::std::string* os) {
  if (os != NULL) {
    
  } else {
    
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.os)
}

// string problem = 21;
inline void Submission::clear_problem() {
  problem_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::problem() const {
  // @@protoc_insertion_point(field_get:pb.Submission.problem)
  return problem_.GetNoArena();
}
inline void Submission::set_problem(const ::std::string& value) {
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.problem)
}
#if LANG_CXX11
inline void Submission::set_problem(::std::string&& value) {
  
  problem_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.problem)
}
#endif
inline void Submission::set_problem(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.problem)
}
inline void Submission::set_problem(const char* value, size_t size) {
  
  problem_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.problem)
}
inline ::std::string* Submission::mutable_problem() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.problem)
  return problem_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_problem() {
  // @@protoc_insertion_point(field_release:pb.Submission.problem)
  
  return problem_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_problem(::std::string* problem) {
  if (problem != NULL) {
    
  } else {
    
  }
  problem_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), problem);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.problem)
}

// string instance = 22;
inline void Submission::clear_instance() {
  instance_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::instance() const {
  // @@protoc_insertion_point(field_get:pb.Submission.instance)
  return instance_.GetNoArena();
}
inline void Submission::set_instance(const ::std::string& value) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.instance)
}
#if LANG_CXX11
inline void Submission::set_instance(::std::string&& value) {
  
  instance_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.instance)
}
#endif
inline void Submission::set_instance(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.instance)
}
inline void Submission::set_instance(const char* value, size_t size) {
  
  instance_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.instance)
}
inline ::std::string* Submission::mutable_instance() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.instance)
  return instance_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_instance() {
  // @@protoc_insertion_point(field_release:pb.Submission.instance)
  
  return instance_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_instance(::std::string* instance) {
  if (instance != NULL) {
    
  } else {
    
  }
  instance_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instance);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.instance)
}

// string duration = 23;
inline void Submission::clear_duration() {
  duration_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::duration() const {
  // @@protoc_insertion_point(field_get:pb.Submission.duration)
  return duration_.GetNoArena();
}
inline void Submission::set_duration(const ::std::string& value) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.duration)
}
#if LANG_CXX11
inline void Submission::set_duration(::std::string&& value) {
  
  duration_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.duration)
}
#endif
inline void Submission::set_duration(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.duration)
}
inline void Submission::set_duration(const char* value, size_t size) {
  
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.duration)
}
inline ::std::string* Submission::mutable_duration() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.duration)
  return duration_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_duration() {
  // @@protoc_insertion_point(field_release:pb.Submission.duration)
  
  return duration_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_duration(::std::string* duration) {
  if (duration != NULL) {
    
  } else {
    
  }
  duration_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duration);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.duration)
}

// double obj = 31;
inline void Submission::clear_obj() {
  obj_ = 0;
}
inline double Submission::obj() const {
  // @@protoc_insertion_point(field_get:pb.Submission.obj)
  return obj_;
}
inline void Submission::set_obj(double value) {
  
  obj_ = value;
  // @@protoc_insertion_point(field_set:pb.Submission.obj)
}

// string email = 32;
inline void Submission::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::email() const {
  // @@protoc_insertion_point(field_get:pb.Submission.email)
  return email_.GetNoArena();
}
inline void Submission::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.email)
}
#if LANG_CXX11
inline void Submission::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.email)
}
#endif
inline void Submission::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.email)
}
inline void Submission::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.email)
}
inline ::std::string* Submission::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_email() {
  // @@protoc_insertion_point(field_release:pb.Submission.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.email)
}

// string date = 33;
inline void Submission::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Submission::date() const {
  // @@protoc_insertion_point(field_get:pb.Submission.date)
  return date_.GetNoArena();
}
inline void Submission::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Submission.date)
}
#if LANG_CXX11
inline void Submission::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Submission.date)
}
#endif
inline void Submission::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Submission.date)
}
inline void Submission::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Submission.date)
}
inline ::std::string* Submission::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:pb.Submission.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Submission::release_date() {
  // @@protoc_insertion_point(field_release:pb.Submission.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Submission::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:pb.Submission.date)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_GateAssignment_2eproto
